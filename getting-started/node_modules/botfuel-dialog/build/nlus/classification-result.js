'use strict';

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var logger = require('logtown')('Intent'); /**
                                            * Copyright (c) 2017 - present, Botfuel (https://www.botfuel.io).
                                            *
                                            * Licensed under the Apache License, Version 2.0 (the "License");
                                            * you may not use this file except in compliance with the License.
                                            * You may obtain a copy of the License at
                                            *
                                            * http://www.apache.org/licenses/LICENSE-2.0
                                            *
                                            * Unless required by applicable law or agreed to in writing, software
                                            * distributed under the License is distributed on an "AS IS" BASIS,
                                            * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
                                            * See the License for the specific language governing permissions and
                                            * limitations under the License.
                                            */

var SdkError = require('../errors/sdk-error');

/** ClassificationResult class */

var ClassificationResult = function () {

  /**
   * @constructor
   * @param data data receive from trainer api request
   */
  function ClassificationResult(data) {
    _classCallCheck(this, ClassificationResult);

    logger.debug('constructor');

    this.type = this.getType(data.type);
    this.label = data.label;
    this.resolvePrompt = data.resolvePrompt;

    var name = data.name || (this.isQnA() ? 'qnas' : data.label);
    if (!name) {
      throw new SdkError('Intent constructor: data must contain label or name');
    }
    this.name = name;

    if (this.isQnA()) {
      this.answers = data.answers;
    }
  }

  /**
   * Parses type from data.
   * @param type - type
   * @returns static TYPE
   */


  _createClass(ClassificationResult, [{
    key: 'getType',
    value: function getType(type) {
      if (!type) {
        throw new SdkError('Intent constructor: data must contain type');
      }

      if (type.toLowerCase() === 'intent') {
        return ClassificationResult.TYPE_INTENT;
      } else if (type.toLowerCase() === 'qna') {
        return ClassificationResult.TYPE_QNA;
      }
      throw new SdkError('Intent constructor: invalid intent type: ' + type);
    }

    /**
     * Returns true if intent is QnA.
     */

  }, {
    key: 'isQnA',
    value: function isQnA() {
      return this.type === ClassificationResult.TYPE_QNA;
    }
  }]);

  return ClassificationResult;
}();

ClassificationResult.TYPE_QNA = 'QnA';
ClassificationResult.TYPE_INTENT = 'Intent';


module.exports = ClassificationResult;