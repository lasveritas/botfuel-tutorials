'use strict';

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _asyncToGenerator(fn) { return function () { var gen = fn.apply(this, arguments); return new Promise(function (resolve, reject) { function step(key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { return Promise.resolve(value).then(function (value) { step("next", value); }, function (err) { step("throw", err); }); } } return step("next"); }); }; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/**
 * Copyright (c) 2017 - present, Botfuel (https://www.botfuel.io).
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

var _ = require('lodash');
var logger = require('logtown')('PromptDialog');

var _require = require('../utils/entities'),
    filterIntersectingEntities = _require.filterIntersectingEntities;

var Dialog = require('./dialog');

/**
 * The prompt dialog prompts the user for a number of entities.
 * The dialog parameters is an Object containing:
 *   - a namespace String representing the name of the dialog
 *   - an entities Object of the form:
 * ```
 *     <entity name>: {
 *         dim: String,
 *         priority: entities parameters will be matched with potential raw entities
 *             in order or priority (highest first)
 *         isFulfilled: Function returning a boolean that determines
 *             when to stop (true) or continue (false)
 *         reducer: Function that determines what to do each time a raw entity
 *             matches with an entity parameter: replace the previously matched entity, append it...
 *     }
 * ```
 * @extends Dialog
 */

var PromptDialog = function (_Dialog) {
  _inherits(PromptDialog, _Dialog);

  /**
   * @constructor
   * @param {class} bot - the bot
   * @param {Object} parameters - the dialog parameters,
   * parameters.entities is a map mapping entities to optional parameters
   */
  function PromptDialog(bot, parameters) {
    _classCallCheck(this, PromptDialog);

    return _possibleConstructorReturn(this, (PromptDialog.__proto__ || Object.getPrototypeOf(PromptDialog)).call(this, bot, { reentrant: true }, parameters));
  }

  /**
   * Attempt to match an entity parameter with raw entities candidates extracted from a message.
   * We apply the reducer function to a raw entity candidate until we run out of candidates or
   * if the isFulfilled condition is met.
   * @param {Object} entity - entity parameter
   * we want to match with one or more raw entities
   * @param {Array<Object>} candidates - array of raw entities extracted
   * from a message: {
   *     dim: String,
   *     body: String,
   *     start: Number,
   *     end: Number,
   *     values: Array<Object>
   * }
   * @param {Object} initialValue - initial value of the entity we want to match
   * @returns {Object} object containing
   * remainingCandidates (candidates minus candidates used) and
   * newValue (value we matched with the parameter)
   */


  _createClass(PromptDialog, [{
    key: 'matchEntityWithCandidates',
    value: function matchEntityWithCandidates(entity) {
      var _this2 = this;

      var candidates = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];
      var initialValue = arguments[2];

      logger.debug('matchEntityWithCandidates', { entity: entity, candidates: candidates, initialValue: initialValue });
      var sameDimCandidates = candidates.filter(function (candidate) {
        return candidate.dim === entity.dim;
      });
      // Check if the parameter is already fulfilled with its initial value
      // If so, we replace the fulfilled parameterâ€™s entity
      // with the first candidate of the same dimension
      var replace = entity.isFulfilled(initialValue, {
        dialogEntities: {},
        dialogParameters: this.parameters
      }) && sameDimCandidates.length >= 1;
      if (replace) {
        var chosenCandidate = sameDimCandidates[0];
        candidates = filterIntersectingEntities(candidates, chosenCandidate);
        if (Array.isArray(initialValue)) {
          initialValue = [chosenCandidate];
        } else {
          initialValue = chosenCandidate;
        }
      }
      return candidates.filter(function (candidate) {
        return candidate.dim === entity.dim;
      }).reduce(function (_ref, candidate) {
        var newValue = _ref.newValue,
            remainingCandidates = _ref.remainingCandidates;

        if (entity.isFulfilled(newValue, {
          dialogEntities: {},
          dialogParameters: _this2.parameters
        })) {
          return { newValue: newValue, remainingCandidates: remainingCandidates };
        }
        return {
          newValue: entity.reducer(newValue, candidate),
          remainingCandidates: filterIntersectingEntities(remainingCandidates, candidate)
        };
      }, { newValue: initialValue, remainingCandidates: candidates });
    }

    /**
     * Update entities with default values.
     * @param {Object} entities - map of entities expected by the dialog: {
     *   <entityName>: {
     *     dim: String,
     *     priority: Number,
     *     isFulfilled: Function()
     *     reducer: Function(),
     *   }
     * }
     * @returns {Object} updated map of entities
     */

  }, {
    key: 'updateEntityWithDefaultValues',
    value: function updateEntityWithDefaultValues(entities) {
      logger.debug('updateEntityWithDefaultValues', { entities: entities });
      return Object.keys(entities).reduce(function (allEntities, name) {
        var entity = entities[name];
        return _extends({}, allEntities, _defineProperty({}, name, {
          dim: entity.dim,
          // If the reducer function is not defined,
          // we replace the old entities by the new ones
          reducer: entity.reducer || function (oldEntities, newEntities) {
            return newEntities;
          },
          // If the isFulfilled function is not defined,
          // we check that the entity is not null and not undefined
          isFulfilled: entity.isFulfilled || function (e) {
            return e != null;
          },
          // Because we need to to be able to override them but we want unfulfilled parameters
          // to have priority over them
          priority: entity.priority || 0
        }));
      }, {});
    }

    /**
     * Sort expected entities by:
     * - isFulfilled descending (unfulfilled first)
     * - then priority descending (highest priority first)
     * @param {Object} matchedEntities - map of matched entities
     * @param {Object} expectedEntities - map of entities expected by the dialog: {
     *   <entityName>: {
     *     dim: String,
     *     priority: Number,
     *     isFulfilled: Function()
     *     reducer: Function(),
     *   }
     * }
     * @param {String} previousQuestionEntity - previous question entity
     * @returns {String[]} array of entity names
     */

  }, {
    key: 'getSortedEntities',
    value: function getSortedEntities(matchedEntities, expectedEntities, previousQuestionEntity) {
      var _this3 = this;

      logger.debug('getSortedEntities', { matchedEntities: matchedEntities, expectedEntities: expectedEntities, previousQuestionEntity: previousQuestionEntity });
      return Object.keys(expectedEntities).sort(function (nameA, nameB) {
        var entityA = expectedEntities[nameA];
        var entityB = expectedEntities[nameB];
        var priorityA = entityA.priority;
        var priorityB = entityB.priority;
        var isFulfilledA = entityA.isFulfilled(matchedEntities[nameA], {
          dialogEntities: matchedEntities,
          dialogParameters: _this3.parameters
        }) ? 0 : 1;
        var isFulfilledB = entityB.isFulfilled(matchedEntities[nameB], {
          dialogEntities: matchedEntities,
          dialogParameters: _this3.parameters
        }) ? 0 : 1;
        if (isFulfilledB !== isFulfilledA) {
          return isFulfilledB - isFulfilledA;
        }

        if (priorityA === priorityB && previousQuestionEntity) {
          if (previousQuestionEntity === nameA) {
            return 0;
          }

          if (previousQuestionEntity === nameB) {
            return 1;
          }
        }

        return priorityB - priorityA;
      });
    }

    /**
     * Computes matched and missing entities.
     * @param {Array.<Object[]>} candidates - array of raw entities given by the extractor.
     * They are candidates for the entity parameters
     * @param {Object} dialogEntities - map of entities expected by the dialog: {
     *   <entityName>: {
     *     dim: String,
     *     priority: Number,
     *     isFulfilled: Function()
     *     reducer: Function(),
     *   }
     * }
     * @param {Object} previouslyMatchedEntities - a map of the entities
     * already matched for this dialog:
     * {
     *   <entityName>: <messageEntity>
     * }
     * @param {String} previousQuestionEntity - previous question entity
     * @returns {Object} object containing missingEntities and matchedEntities
     */

  }, {
    key: 'computeEntities',
    value: function () {
      var _ref2 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee(candidates, dialogEntities) {
        var previouslyMatchedEntities = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
        var previousQuestionEntity = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : undefined;

        var sortedDialogEntityNames, missingEntities, matchedEntities, remainingCandidates, _iteratorNormalCompletion, _didIteratorError, _iteratorError, _iterator, _step, name, entity, initialValue, _matchEntityWithCandi, newValue, newRemainingCandidates, isFulfilled;

        return regeneratorRuntime.wrap(function _callee$(_context) {
          while (1) {
            switch (_context.prev = _context.next) {
              case 0:
                logger.debug('computeEntities', {
                  candidates: candidates,
                  dialogEntities: dialogEntities,
                  previouslyMatchedEntities: previouslyMatchedEntities,
                  previousQuestionEntity: previousQuestionEntity
                });

                // Setup default values for entities
                dialogEntities = this.updateEntityWithDefaultValues(dialogEntities);

                sortedDialogEntityNames = this.getSortedEntities(previouslyMatchedEntities, dialogEntities, previousQuestionEntity);
                missingEntities = dialogEntities;
                matchedEntities = previouslyMatchedEntities;
                remainingCandidates = candidates;
                _iteratorNormalCompletion = true;
                _didIteratorError = false;
                _iteratorError = undefined;
                _context.prev = 9;


                for (_iterator = sortedDialogEntityNames[Symbol.iterator](); !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
                  name = _step.value;
                  entity = dialogEntities[name];
                  initialValue = previouslyMatchedEntities[name];
                  _matchEntityWithCandi = this.matchEntityWithCandidates(entity, remainingCandidates, initialValue), newValue = _matchEntityWithCandi.newValue, newRemainingCandidates = _matchEntityWithCandi.remainingCandidates;

                  logger.debug('computeEntities: after matchParameterWithCandidates', {
                    name: name,
                    newValue: newValue,
                    newRemainingCandidates: newRemainingCandidates
                  });

                  remainingCandidates = newRemainingCandidates;

                  if (newValue) {
                    matchedEntities = _extends({}, matchedEntities, _defineProperty({}, name, newValue));
                  }

                  isFulfilled = entity.isFulfilled(newValue, {
                    dialogEntities: matchedEntities,
                    dialogParameters: this.parameters
                  });

                  // If an entity matching the one we are expecting was found,
                  // remove it from missing entities
                  // If it was not found, keep missing entities intact

                  missingEntities = isFulfilled ? _.omit(missingEntities, [name]) : missingEntities;
                }

                // transform missingEntities to a Map, ordered by priority
                _context.next = 17;
                break;

              case 13:
                _context.prev = 13;
                _context.t0 = _context['catch'](9);
                _didIteratorError = true;
                _iteratorError = _context.t0;

              case 17:
                _context.prev = 17;
                _context.prev = 18;

                if (!_iteratorNormalCompletion && _iterator.return) {
                  _iterator.return();
                }

              case 20:
                _context.prev = 20;

                if (!_didIteratorError) {
                  _context.next = 23;
                  break;
                }

                throw _iteratorError;

              case 23:
                return _context.finish(20);

              case 24:
                return _context.finish(17);

              case 25:
                missingEntities = this.sortMissingEntities(missingEntities);

                return _context.abrupt('return', { matchedEntities: matchedEntities, missingEntities: missingEntities });

              case 27:
              case 'end':
                return _context.stop();
            }
          }
        }, _callee, this, [[9, 13, 17, 25], [18,, 20, 24]]);
      }));

      function computeEntities(_x2, _x3) {
        return _ref2.apply(this, arguments);
      }

      return computeEntities;
    }()

    /**
     * Compute sorted missing entities as a Map, ordered by priority
     * @param {Object} missingEntities - missing entities
     * @returns {Object} map of missing entities with key sorted
     */

  }, {
    key: 'sortMissingEntities',
    value: function sortMissingEntities(missingEntities) {
      logger.debug('sortMissingEntities', { missingEntities: missingEntities });
      if (Object.keys(missingEntities).length === 0) {
        return new Map();
      }
      var sortedNames = Object.keys(missingEntities).sort(function (a, b) {
        return missingEntities[b].priority - missingEntities[a].priority;
      });
      return new Map(sortedNames.map(function (name) {
        return [name, missingEntities[name]];
      }));
    }

    /**
     * Executes the dialog.
     * @async
     * @param {Object} userMessage - the user message
     * @param {Object} data - the data
     * @returns {Promise.<Object>} an action
     */

  }, {
    key: 'execute',
    value: function () {
      var _ref3 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee2(userMessage, data) {
        var _data, messageEntities, userId, dialogCache, previouslyMatchedEntities, previousQuestionEntity, _ref4, missingEntities, matchedEntities, extraData, botMessages, action;

        return regeneratorRuntime.wrap(function _callee2$(_context2) {
          while (1) {
            switch (_context2.prev = _context2.next) {
              case 0:
                logger.debug('execute', { userMessage: userMessage, data: data });
                // get message entities extracted from the message
                _data = data, messageEntities = _data.messageEntities;
                userId = userMessage.user;
                _context2.next = 5;
                return this.brain.conversationGet(userId, this.parameters.namespace);

              case 5:
                dialogCache = _context2.sent;
                previouslyMatchedEntities = dialogCache && dialogCache._entities || {};
                previousQuestionEntity = dialogCache && dialogCache._question || undefined;

                logger.debug('execute', { previouslyMatchedEntities: previouslyMatchedEntities });
                // Get missing entities and matched entities
                _context2.next = 11;
                return this.computeEntities(messageEntities, this.parameters.entities, previouslyMatchedEntities, previousQuestionEntity);

              case 11:
                _ref4 = _context2.sent;
                missingEntities = _ref4.missingEntities;
                matchedEntities = _ref4.matchedEntities;

                logger.debug('execute', { missingEntities: missingEntities, matchedEntities: matchedEntities });
                // save matched entities and next question in the brain
                _context2.next = 17;
                return this.brain.conversationSet(userId, this.parameters.namespace, {
                  _entities: matchedEntities,
                  _question: missingEntities.size > 0 ? missingEntities.keys().next().value : undefined
                });

              case 17:
                data = _extends({}, data, { missingEntities: missingEntities, matchedEntities: matchedEntities });
                _context2.next = 20;
                return this.dialogWillDisplay(userMessage, data);

              case 20:
                extraData = _context2.sent;

                data = this.mergeData(extraData, data);
                _context2.next = 24;
                return this.display(userMessage, data);

              case 24:
                botMessages = _context2.sent;
                _context2.next = 27;
                return this.dialogWillComplete(userMessage, data);

              case 27:
                action = _context2.sent;
                return _context2.abrupt('return', {
                  action: action,
                  botMessages: botMessages
                });

              case 29:
              case 'end':
                return _context2.stop();
            }
          }
        }, _callee2, this);
      }));

      function execute(_x6, _x7) {
        return _ref3.apply(this, arguments);
      }

      return execute;
    }()

    /** @inheritDoc */

  }, {
    key: 'dialogWillComplete',
    value: function () {
      var _ref5 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee3(userMessage, data) {
        return regeneratorRuntime.wrap(function _callee3$(_context3) {
          while (1) {
            switch (_context3.prev = _context3.next) {
              case 0:
                logger.debug('dialogWillComplete', { userMessage: userMessage, data: data });

                if (!(data.missingEntities.size === 0)) {
                  _context3.next = 3;
                  break;
                }

                return _context3.abrupt('return', this.complete());

              case 3:
                return _context3.abrupt('return', this.wait());

              case 4:
              case 'end':
                return _context3.stop();
            }
          }
        }, _callee3, this);
      }));

      function dialogWillComplete(_x8, _x9) {
        return _ref5.apply(this, arguments);
      }

      return dialogWillComplete;
    }()
  }]);

  return PromptDialog;
}(Dialog);

module.exports = PromptDialog;