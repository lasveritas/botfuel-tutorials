'use strict';

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

/**
 * Copyright (c) 2017 - present, Botfuel (https://www.botfuel.io).
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/* eslint-disable valid-jsdoc */
var Diacritics = require('diacritics');
var ExtractorError = require('../errors/extractor-error');
var logger = require('logtown')('Corpus');

/**
 * Class for handling corpora.
 *
 * A corpus is a list of words.
 * Within a corpus, we group together words sharing a common meaning.
 * Within a subgroup, a specific word is distinguished.
 *
 * A corpus could then be represented by the following table (or matrix) where:
 * - each row contains words sharing a common meaning,
 * - the first word of each row is the distinguished word used to represent the subgroup.
 *
 * | main word | synonym          | another synonym          | yet another synonym          |
 * | :-------- | :--------------- | :----------------------- | :--------------------------- |
 * | word1     | synonym of word1 |                          |                              |
 * | word2     | synonym of word2 | another synonym of word2 | yet another synonym of word2 |
 * | word3     | synonym of word3 | another synonym of word3 |                              |
 *
 * Two specific edge-cases:
 * - a table with a single line is a set of synonyms,
 * - a table with a single column is a set of words without synonyms.
 */

var Corpus = function () {
  /**
   * @constructor
   * @param {String[][]} matrix - the corpus matrix,
   * a row of the matrix corresponds to words with common meaning
   * @param {String} path - the file path
   */
  function Corpus(matrix, name) {
    _classCallCheck(this, Corpus);

    logger.debug('constructor', matrix);
    var _iteratorNormalCompletion = true;
    var _didIteratorError = false;
    var _iteratorError = undefined;

    try {
      for (var _iterator = matrix[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
        var row = _step.value;
        var _iteratorNormalCompletion2 = true;
        var _didIteratorError2 = false;
        var _iteratorError2 = undefined;

        try {
          for (var _iterator2 = row[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
            var word = _step2.value;

            if (word.length === 0) {
              throw new ExtractorError('The corpus ' + name + ' is not formatted properly.\n           Make sure it doesn\u2019t contain trailing commas.');
            }
          }
        } catch (err) {
          _didIteratorError2 = true;
          _iteratorError2 = err;
        } finally {
          try {
            if (!_iteratorNormalCompletion2 && _iterator2.return) {
              _iterator2.return();
            }
          } finally {
            if (_didIteratorError2) {
              throw _iteratorError2;
            }
          }
        }
      }
    } catch (err) {
      _didIteratorError = true;
      _iteratorError = err;
    } finally {
      try {
        if (!_iteratorNormalCompletion && _iterator.return) {
          _iterator.return();
        }
      } finally {
        if (_didIteratorError) {
          throw _iteratorError;
        }
      }
    }

    this.matrix = matrix;
  }

  /**
   * Normalizes a sentence.
   * @static
   * @param {String} sentence - the sentence
   * @param {Object} options - the normalization options
   * @returns {String} the normalized sentence
   */


  _createClass(Corpus, [{
    key: 'getValue',


    /**
     * Gets matching value for a key.
     * @param {String} key - the key
     * @param {Object} options - the normalization options
     * @returns {String} the matching value
     */
    value: function getValue(key, options) {
      logger.debug('getValue', key, options);
      var normalizedKey = Corpus.normalize(key, options);
      var _iteratorNormalCompletion3 = true;
      var _didIteratorError3 = false;
      var _iteratorError3 = undefined;

      try {
        for (var _iterator3 = this.matrix[Symbol.iterator](), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {
          var row = _step3.value;
          var _iteratorNormalCompletion4 = true;
          var _didIteratorError4 = false;
          var _iteratorError4 = undefined;

          try {
            for (var _iterator4 = row[Symbol.iterator](), _step4; !(_iteratorNormalCompletion4 = (_step4 = _iterator4.next()).done); _iteratorNormalCompletion4 = true) {
              var word = _step4.value;

              var normalizedWord = Corpus.normalize(word, options);
              if (normalizedKey === normalizedWord) {
                return row[0];
              }
            }
          } catch (err) {
            _didIteratorError4 = true;
            _iteratorError4 = err;
          } finally {
            try {
              if (!_iteratorNormalCompletion4 && _iterator4.return) {
                _iterator4.return();
              }
            } finally {
              if (_didIteratorError4) {
                throw _iteratorError4;
              }
            }
          }
        }
      } catch (err) {
        _didIteratorError3 = true;
        _iteratorError3 = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion3 && _iterator3.return) {
            _iterator3.return();
          }
        } finally {
          if (_didIteratorError3) {
            throw _iteratorError3;
          }
        }
      }

      return null;
    }
  }], [{
    key: 'normalize',
    value: function normalize(sentence, options) {
      logger.debug('Corpus.normalize', sentence, options);
      if (options === undefined || options.caseSensitive !== true) {
        sentence = sentence.toLowerCase();
      }
      if (options === undefined || options.keepQuotes !== true) {
        sentence = sentence.replace("'", ' ');
      }
      if (options === undefined || options.keepDashes !== true) {
        sentence = sentence.replace('-', ' ');
      }
      if (options === undefined || options.keepAccents !== true) {
        sentence = Diacritics.remove(sentence);
      }
      return sentence.replace(/ {2,}/g, ' ');
    }
  }]);

  return Corpus;
}();

module.exports = Corpus;